/* eslint-disable import/no-extraneous-dependencies */
const { CLIEngine } = require('eslint');
const { writeFileSync } = require('fs');
const elements = require('html-tags');
const { resolve } = require('path');

const htmlElementOverload = element =>
  `
(
  props: { as: '${element}' } & StylingProps & JSX.IntrinsicElements['${element}'] /* & Props */,
  context?: any,
): ReactElement | null;
`.trim();

const unknownElements = new Set(['math', 'rb', 'rtc', 'slot', 'template']);

const source = `
/**
 * This file is generated by ../../tooles/generateaComponentType.js
 */

import { ComponentClass, FunctionComponent, ReactElement } from 'react';
import { Theme } from './theme';

export interface ComponentFactory<TDefaultStylingProps> {
  <P, TStylingProps = TDefaultStylingProps, TExtraStylers = { [key: string]: (theme: Theme, propValue: any) => any }>(
    As: FunctionComponent<P>,
    options?: { 
      defaultProps?: P & TDefaultStylingProps; 
      displayName?: string;
      extraStylers?: TExtraStylers;
    }
  ): VisageComponent<P, TStylingProps & Partial<{ [K in keyof TStylingProps]: { [EK in keyof TExtraStylers]: any } }>>;
  <P, TStylingProps = TDefaultStylingProps, TExtraStylers = { [key: string]: (theme: Theme, propValue: any) => any }>(
    As: ComponentClass<P>,
    options?: { 
      defaultProps?: P & TDefaultStylingProps; 
      displayName?: string;
      extraStylers?: TExtraStylers;
    }
  ): VisageComponent<P, TStylingProps & Partial<{ [K in keyof TStylingProps]: { [EK in keyof TExtraStylers]: any } }>>;
  <P, PS, TStylingProps = TDefaultStylingProps, TExtraStylers = { [key: string]: (theme: Theme, propValue: any) => any }>(
    As: VisageComponent<P, PS>,
    options?: { 
      defaultProps?: P & TDefaultStylingProps; 
      displayName?: string;
      extraStylers?: TExtraStylers;
    }
  ): VisageComponent<P & PS, TStylingProps & Partial<{ [K in keyof TStylingProps]: { [EK in keyof TExtraStylers]: any } }>>;
  ${elements
    .filter(el => !unknownElements.has(el))
    .map(el =>
      `
      <TExtraStylers = { [key: string]: (theme: Theme, propValue: any) => any }>(As: '${el}', options?: { 
        defaultProps?: JSX.IntrinsicElements['${el}'] & TDefaultStylingProps; 
        displayName?: string; 
        extraStylers?: TExtraStylers;
      }): VisageComponent<JSX.IntrinsicElements['${el}'],  TDefaultStylingProps & Partial<{ [K in keyof TDefaultStylingProps]: { [EK in keyof TExtraStylers]: any } }>>;
    `.trim(),
    )
    .join('')}
}

export interface VisageComponent<Props = {}, StylingProps = {}> {
  <P>(
    props: { as: FunctionComponent<P> } & StylingProps & P & Props,
    context?: any,
    ): ReactElement | null;
    <P>(
      props: { as: ComponentClass<P>} & StylingProps & P & Props,
      context?: any,
      ): ReactElement | null;
      <P, PS>(
  props: { as: VisageComponent<P, PS> } & StylingProps & PS & P & Props,
  context?: any,
  ): ReactElement | null;
  ${elements
    .filter(el => !unknownElements.has(el))
    .map(htmlElementOverload)
    .join('')}
    (props: { 
      as?: FunctionComponent<any> | ComponentClass<any> | VisageComponent | keyof JSX.IntrinsicElements 
    } & StylingProps & Props, context?: any): ReactElement | null;
  }
`.trim();

const destination = resolve(__dirname, '../src/types/component.ts');

const engine = new CLIEngine({
  fix: true,
});

writeFileSync(
  destination,
  engine.executeOnText(source, 'component.ts').results[0].output || source,
);
